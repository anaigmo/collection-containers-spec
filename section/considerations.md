## Considerations {#considerations}

### Identifying collections and containers

An `rr:template` or `rml:reference` may be provided for the generation of blank node IDs (`rr:BlankNode`) or IRIs (`rr:IRI`). In some cases, there are challenges when identifiers are generated. The challenge generating identifiers for collections and containers: one needs to be careful when a gather map uses multi-valued references in the template or generates multiple collections and containers:

* In the former, the gather map must return “deep” copies of collections. This is to avoid only generating a new IRI or blank node identifier for the first cons-pair and hence having multiple lists sharing the same sublist.
* In the latter, we may end up with multiple lists and containers sharing the same blank node identifier or IRI, which may produce valid RDF, but nonsensical containers and collections.

If no `rr:template` or `rml:reference` is provided for generating blank node IDs (`rr:BlankNode`) or IRIs (`rr:IRI`), then each iteration generates a new blank node identifier for the collection or container.


<!--
### Gather maps yielding the same identifier during different iterations

If term maps were to generate the same identifier for collections and containers, this might result in valid RDF but ill-formed RDF collections and containers. We identify two cases:

*  A gather map yields the same identifier during two iterations. The nature of the resource (collection or container) remains the same, and values are appended.

* Two gather maps yield the same identifier during two iterations. The nature of the resources generated by these gather maps may be different, resulting in resources of two different types (e.g., rdf:List and rdf:Bag). An RML processor will produce those as this is valid RDF, although the respective lists and containers are not well-formed.
-->

### The use of `rr:column`

In RML, `rr:column` is considered a subproperty of `rml:reference`. One can still avail of `rr:column` when creating mappings for relational databases. The use of `rr:column` is not discouraged, but one is encouraged to favor `rml:reference`. 


### Using a `rml:GatherMap` in various types of term map

Although most examples demonstrate the use of a gather map in the context of an object map, a gather map is a regular term map.
As such, it can be used in other types of term maps such as a subject or predicate map.

Term maps generate single RDF terms to be used as the terms of RDF triples.
If such a term map generates a collection or container by means of a gather map, the term retained to form an RDF triple is the head node of the collection or container.
In the case of an RDF list, this is the node that is the subject of the first `rdf:first` predicate.

The [examples section](#gatherinsubject) demonstrates how a gather map can be used within a subject map.

### Valid RDF and well-formedness of Collections and Containers

The mapping language proposed here guarantees the generation of valid RDF. However, the well-formedness of RDF collections and containers is up to the person creating and managing the mappings. An RML processor with support for gather maps may include a validator for collections and containers, but this is not required. In this section, we provide an example of a mapping that generates valid RDF but ill-formed lists.

Given the JSON document below.

```json
[ 
  { "id": "a",  "values": [ "1" , "2" ] },
  { "id": "a",  "values": [ "3" , "4" ] },
  { "id": "b",  "values": [ "5" , "6" ] } 
]
```

We are going to create an RML mapping that will generate valid RDF, but ill-formed lists. In the mapping below, we will generate blank nodes who are identified by the value of `id` in each element of our JSON document.

```turtle
@prefix rml: <http://semweb.mmlab.be/ns/rml#>.
@prefix rr:  <http://www.w3.org/ns/r2rml#>.
@prefix ql:  <http://semweb.mmlab.be/ns/ql#>.
@prefix ex:  <http://example.com/ns>.
@base        <http://example.com/ns>.

<#TM> a rr:TriplesMap;
  rml:logicalSource [
    rml:source "data.json" ;
    rml:referenceFormulation ql:JSONPath ;
    rml:iterator "$.*" ;
  ] ;

  rr:subjectMap [
    rr:template "{id}" ;
  ] ;

  rr:predicateObjectMap [
    rr:predicate ex:with ;
    rr:objectMap [
        # Generate blank node identifiers for lists based on the value of "id"
        rr:template "{id}" ;
        rml:gather ( [ rml:reference "values.*" ; ] ) ;
        rml:gatherAs rdf:List ;
    ] ;
  ] ;
.
```

The first two iterations will refer to the same blank node, as they both have the value `"a"` for the key `id`. As two lists are being generated, this blank node will have two `rdf:first` and two `rdf:rest` properties as that blank node is used for two cons-pairs. This cons-pair is ill-formed and hence so are the lists. The third iteration does yield a well-formed list. The output generated with this mapping is, however, valid RDF.

```turtle
@prefix ex:  <http://example.org/ns#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

ex:a    ex:with     _:b0 .

_:b0    rdf:first   1 , 3 ;
        rdf:rest    ( 2 ) ;
        rdf:rest    ( 4 ) .

ex:b    ex:with (5 6) .
```
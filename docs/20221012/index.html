<!DOCTYPE html><html lang="en" dir="ltr"><head>
<meta charset="utf-8">
<meta name="generator" content="ReSpec 32.3.0">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<style>
dfn{cursor:pointer}
.dfn-panel{position:absolute;z-index:35;min-width:300px;max-width:500px;padding:.5em .75em;margin-top:.6em;font-family:"Helvetica Neue",sans-serif;font-size:small;background:#fff;color:#000;box-shadow:0 1em 3em -.4em rgba(0,0,0,.3),0 0 1px 1px rgba(0,0,0,.05);border-radius:2px}
.dfn-panel:not(.docked)>.caret{position:absolute;top:-9px}
.dfn-panel:not(.docked)>.caret::after,.dfn-panel:not(.docked)>.caret::before{content:"";position:absolute;border:10px solid transparent;border-top:0;border-bottom:10px solid #fff;top:0}
.dfn-panel:not(.docked)>.caret::before{border-bottom:9px solid #a2a9b1}
.dfn-panel *{margin:0}
.dfn-panel b{display:block;color:#000;margin-top:.25em}
.dfn-panel ul a[href]{color:#333}
.dfn-panel>div{display:flex}
.dfn-panel a.self-link{font-weight:700;margin-right:auto}
.dfn-panel .marker{padding:.1em;margin-left:.5em;border-radius:.2em;text-align:center;white-space:nowrap;font-size:90%;color:#040b1c}
.dfn-panel .marker.dfn-exported{background:#d1edfd;box-shadow:0 0 0 .125em #1ca5f940}
.dfn-panel .marker.idl-block{background:#8ccbf2;box-shadow:0 0 0 .125em #0670b161}
.dfn-panel a:not(:hover){text-decoration:none!important;border-bottom:none!important}
.dfn-panel a[href]:hover{border-bottom-width:1px}
.dfn-panel ul{padding:0}
.dfn-panel li{margin-left:1em}
.dfn-panel.docked{position:fixed;left:.5em;top:unset;bottom:2em;margin:0 auto;max-width:calc(100vw - .75em * 2 - .5em - .2em * 2);max-height:30vh;overflow:auto}
</style>
    
<title>Collections and Containers in RML</title>
    
    
<link rel="stylesheet" type="text/css" href="../resources/css/extras.css">
    
    
<style type="text/css">

        /* Adapted from R2RML */
        pre { 
            word-wrap:normal
        }
        pre.ex-input,
        pre.ex-mapping, 
        pre.ex-output,
        pre.ex-target,
        pre.ex-access {
            margin-top: 1.5em;
            padding: 1em; 
            font-size: 75%;
        }
        pre.ex-input:before,
        pre.ex-mapping:before,
        pre.ex-output:before, 
        pre.ex-target:before,
        pre.ex-access:before {
            background: white;
            display: block;
            font-family: sans-serif;
            font-size: 90%;
            margin: -1.5em 0 0.5em 0;
            padding: 0.4em 0.4em;
            width: 18em;
        }
        /* Input data example */
        pre.ex-input {
            background: #cee;
        }
        pre.ex-input,
        pre.ex-input:before {
            border: 1px solid #acc;
        }
        pre.ex-input:before {
            content: "Example input data";
        }
        /* RML mapping example */
        pre.ex-mapping {
            background: #eeb;
        }
        pre.ex-mapping,
        pre.ex-mapping:before {
            border: 1px solid #cc9;
        }
        pre.ex-mapping:before {
            content: "Example RML mapping";
        }
        /* Output RDF example */
        pre.ex-output {
            background: #cfc;
        }
        pre.ex-output,
        pre.ex-output:before {
            border: 1px solid #aca;
        }
        pre.ex-output:before {
            content: "Example output RDF";
        }
        /* Target's description example */
        pre.ex-target {
            background: #ffc8d4;
        }
        pre.ex-target,
        pre.ex-target:before {
            border: 1px solid #bbb;
        }
        /* Data access description example */
        pre.ex-access {
            background: #d4dddd;
        }
        pre.ex-access,
        pre.ex-access:before {
            border: 1px solid #cca;
        }

        table, th, td {
          border: 1px solid #cca;
        }

        th {
          background-color: #cca;
        }
    
</style>
    
    
    

<style id="respec-mainstyle">
@keyframes pop{
0%{transform:scale(1,1)}
25%{transform:scale(1.25,1.25);opacity:.75}
100%{transform:scale(1,1)}
}
:is(h1,h2,h3,h4,h5,h6,a) abbr{border:none}
dfn{font-weight:700}
a.internalDFN{color:inherit;border-bottom:1px solid #99c;text-decoration:none}
a.externalDFN{color:inherit;border-bottom:1px dotted #ccc;text-decoration:none}
a.bibref{text-decoration:none}
.respec-offending-element:target{animation:pop .25s ease-in-out 0s 1}
.respec-offending-element,a[href].respec-offending-element{text-decoration:red wavy underline}
@supports not (text-decoration:red wavy underline){
.respec-offending-element:not(pre){display:inline-block}
.respec-offending-element{background:url(data:image/gif;base64,R0lGODdhBAADAPEAANv///8AAP///wAAACwAAAAABAADAEACBZQjmIAFADs=) bottom repeat-x}
}
#references :target{background:#eaf3ff;animation:pop .4s ease-in-out 0s 1}
cite .bibref{font-style:normal}
a[href].orcid{padding-left:4px;padding-right:4px}
a[href].orcid>svg{margin-bottom:-2px}
.toc a,.tof a{text-decoration:none}
a .figno,a .secno{color:#000}
ol.tof,ul.tof{list-style:none outside none}
.caption{margin-top:.5em;font-style:italic}
table.simple{border-spacing:0;border-collapse:collapse;border-bottom:3px solid #005a9c}
.simple th{background:#005a9c;color:#fff;padding:3px 5px;text-align:left}
.simple th a{color:#fff;padding:3px 5px;text-align:left}
.simple th[scope=row]{background:inherit;color:inherit;border-top:1px solid #ddd}
.simple td{padding:3px 10px;border-top:1px solid #ddd}
.simple tr:nth-child(even){background:#f0f6ff}
.section dd>p:first-child{margin-top:0}
.section dd>p:last-child{margin-bottom:0}
.section dd{margin-bottom:1em}
.section dl.attrs dd,.section dl.eldef dd{margin-bottom:0}
#issue-summary>ul{column-count:2}
#issue-summary li{list-style:none;display:inline-block}
details.respec-tests-details{margin-left:1em;display:inline-block;vertical-align:top}
details.respec-tests-details>*{padding-right:2em}
details.respec-tests-details[open]{z-index:999999;position:absolute;border:thin solid #cad3e2;border-radius:.3em;background-color:#fff;padding-bottom:.5em}
details.respec-tests-details[open]>summary{border-bottom:thin solid #cad3e2;padding-left:1em;margin-bottom:1em;line-height:2em}
details.respec-tests-details>ul{width:100%;margin-top:-.3em}
details.respec-tests-details>li{padding-left:1em}
.self-link:hover{opacity:1;text-decoration:none;background-color:transparent}
aside.example .marker>a.self-link{color:inherit}
.header-wrapper{display:flex;align-items:baseline}
:is(h2,h3,h4,h5,h6):not(#toc>h2,#abstract>h2,#sotd>h2,.head>h2){position:relative;left:-.5em}
:is(h2,h3,h4,h5,h6):not(#toch2)+a.self-link{color:inherit;order:-1;position:relative;left:-1.1em;font-size:1rem;opacity:.5}
:is(h2,h3,h4,h5,h6)+a.self-link::before{content:"ยง";text-decoration:none;color:var(--heading-text)}
:is(h2,h3)+a.self-link{top:-.2em}
:is(h4,h5,h6)+a.self-link::before{color:#000}
@media (max-width:767px){
dd{margin-left:0}
}
@media print{
.removeOnSave{display:none}
}
</style>
<meta id="ConnectiveDocSignExtentionInstalled" name="ConnectiveDocSignExtentionInstalled" data-extension-version="1.0.6">
<meta name="description" content="This document describes the [RML] vocabulary and approach to generating RDF containers and collections [RDF11-Concepts].">
<style>
.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}
.hljs-comment,.hljs-quote{color:#717277;font-style:italic}
.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}
.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#ca4706;font-weight:700}
.hljs-literal{color:#0b76c5}
.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#42803c}
.hljs-built_in,.hljs-class .hljs-title{color:#9a6a01}
.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}
.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#336ae3}
.hljs-emphasis{font-style:italic}
.hljs-strong{font-weight:700}
.hljs-link{text-decoration:underline}
</style>
<style>
var{position:relative;cursor:pointer}
var[data-type]::after,var[data-type]::before{position:absolute;left:50%;top:-6px;opacity:0;transition:opacity .4s;pointer-events:none}
var[data-type]::before{content:"";transform:translateX(-50%);border-width:4px 6px 0 6px;border-style:solid;border-color:transparent;border-top-color:#000}
var[data-type]::after{content:attr(data-type);transform:translateX(-50%) translateY(-100%);background:#000;text-align:center;font-family:"Dank Mono","Fira Code",monospace;font-style:normal;padding:6px;border-radius:3px;color:#daca88;text-indent:0;font-weight:400}
var[data-type]:hover::after,var[data-type]:hover::before{opacity:1}
</style>
<script id="initialUserConfig" type="application/json">{
  "format": "markdown",
  "localBiblio": {
    "RDF11-Concepts": {
      "title": "RDF 1.1 Concepts and Abstract Syntax",
      "href": "https://www.w3.org/TR/rdf11-concepts/",
      "status": "W3C Recommendation",
      "publisher": "W3C",
      "date": "25 February 2014",
      "id": "rdf11-concepts"
    },
    "SPARQL": {
      "title": "SPARQL 1.1 Overview",
      "href": "https://www.w3.org/TR/sparql11-overview/",
      "status": "W3C Recommendation",
      "publisher": "W3C",
      "date": "21 March 2013"
    },
    "CSVW": {
      "title": "CSV on the Web: A Primer",
      "href": "https://www.w3.org/TR/tabular-data-primer/",
      "status": "W3C Working Group Note",
      "publisher": "W3C",
      "date": "25 February 2016"
    },
    "DCAT": {
      "title": "Data Catalog Vocabulary (DCAT) Version 2",
      "href": "https://www.w3.org/TR/vocab-dcat-2/",
      "status": "W3C Recommendation",
      "publisher": "W3C",
      "date": "04 February 2020"
    },
    "RML": {
      "title": "RDF Mapping Language (RML)",
      "href": "https://rml.io/specs/rml",
      "status": "Unofficial Draft",
      "publisher": "RML team",
      "date": "06 October 2020",
      "id": "rml"
    },
    "RDFS": {
      "title": "RDF Schema 1.1",
      "href": "https://www.w3.org/TR/2014/REC-rdf-schema-20140225/",
      "status": "W3C Recommendation",
      "publisher": "W3C",
      "date": "25 February 2014"
    },
    "FnO": {
      "title": "The Function Ontology",
      "href": "https://fno.io/spec",
      "status": "Unofficial Draft",
      "publisher": "FnO team",
      "date": "05 January 2021"
    }
  },
  "doRdfa": "true",
  "processVersion": 2021,
  "specStatus": "unofficial",
  "shortName": "collections-in-rml",
  "copyrightStart": "2022",
  "edDraftURI": "https://w3id.org/kg-construct/collections-containers",
  "latestVersion": null,
  "editors": [
    {
      "name": "Christophe Debruyne",
      "company": "Montefiore Institute, University of Liรจge",
      "url": "http://www.christophedebruyne.be/",
      "orcidid": "0000-0003-4734-3847",
      "companyURL": "https://www.montefiore.uliege.be/"
    },
    {
      "name": "Franck Michel",
      "company": "Universitรฉ Cรดte d'Azur, CNRS, Inria",
      "url": "https://w3id.org/people/franckmichel",
      "orcidid": "0000-0001-9064-0463",
      "companyURL": "https://www.cnrs.fr/"
    }
  ],
  "otherLinks": [
    {
      "key": "Website",
      "data": [
        {
          "value": "https://w3id.org/kg-construct/collection-containers",
          "href": "https://w3id.org/kg-construct/collection-containers"
        }
      ]
    }
  ],
  "publishISODate": "2022-10-12T00:00:00.000Z",
  "generatedSubtitle": "Unofficial Draft 12 October 2022"
}</script>
<link rel="stylesheet" href="https://www.w3.org/StyleSheets/TR/2021/W3C-UD"></head>
<body class="h-entry" data-new-gr-c-s-check-loaded="14.1083.0" data-gr-ext-installed=""><div class="head">
    
    <h1 id="title" class="title">Collections and Containers in RML</h1> 
    <p id="w3c-state">Unofficial Draft <time class="dt-published" datetime="2022-10-12">12 October 2022</time></p>
    <details open="">
      <summary>More details about this document</summary>
      <dl>
        
        <dt>Latest published version:</dt><dd>
                none
              </dd>
        <dt>Latest editor's draft:</dt><dd><a href="https://w3id.org/kg-construct/collections-containers">https://w3id.org/kg-construct/collections-containers</a></dd>
        
        
        
        
        
        
        <dt>Editors:</dt><dd class="editor p-author h-card vcard">
    <a class="u-url url p-name fn" href="http://www.christophedebruyne.be/">Christophe Debruyne</a> (<a class="p-org org h-org" href="https://www.montefiore.uliege.be/">Montefiore Institute, University of Liรจge</a>)
  </dd><dd class="editor p-author h-card vcard">
    <a class="u-url url p-name fn" href="https://w3id.org/people/franckmichel">Franck Michel</a> (<a class="p-org org h-org" href="https://www.cnrs.fr/">Universitรฉ Cรดte d'Azur, CNRS, Inria</a>)
  </dd>
        
        
        
        
        <dt>Website</dt><dd>
    <a href="https://w3id.org/kg-construct/collection-containers">https://w3id.org/kg-construct/collection-containers</a>
  </dd>
      </dl>
    </details>
    
    
    <p class="copyright">
      Copyright ยฉ
      2022
      the document editors/authors.
      Text is available under the
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/legalcode">Creative Commons Attribution 4.0 International Public License</a>; additional terms may apply.
    </p>
    <hr title="Separator for header">
  </div>
<section id="abstract" class="introductory"><h2 id="abstract">Abstract</h2><p>This document describes the [<cite><a class="bibref" data-link-type="biblio" href="#bib-rml" title="RDF Mapping Language (RML)">RML</a></cite>] vocabulary and approach to generating RDF containers and collections [<cite><a class="bibref" data-link-type="biblio" href="#bib-rdf11-concepts" title="RDF 1.1 Concepts and Abstract Syntax">RDF11-Concepts</a></cite>].</p>
</section>
<section id="sotd" class="override introductory"><h2>Status of This Document</h2>
<p>This specification was published by the <a href="https://www.w3.org/groups/cg/kg-construct">Knowledge Graph Construction Community Group</a>. It is not a W3C Standard nor is it on the W3C Standards Track. Please note that under the <a href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a> there is a limited opt-out and other conditions apply. Learn more about <a href="https://www.w3.org/community/">W3C Community and Business Groups</a>.</p>
<p><a href="https://github.com/kg-construct/collection-containers-spec/issues">GitHub Issues</a> are preferred for discussion of this specification.</p>
</section><nav id="toc"><h2 class="introductory" id="table-of-contents">Table of Contents</h2><ol class="toc"><li class="tocline"><a class="tocxref" href="#abstract">Abstract</a></li><li class="tocline"><a class="tocxref" href="#sotd">Status of This Document</a></li><li class="tocline"><a class="tocxref" href="#conformance"><bdi class="secno">1. </bdi>Conformance</a></li><li class="tocline"><a class="tocxref" href="#overview"><bdi class="secno">2. </bdi>Overview and Example</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#runningexample"><bdi class="secno">2.1 </bdi>Running example</a></li><li class="tocline"><a class="tocxref" href="#simpleexample"><bdi class="secno">2.2 </bdi>A simple example</a></li><li class="tocline"><a class="tocxref" href="#identifying-collections-and-containers"><bdi class="secno">2.3 </bdi>Identifying collections and containers</a></li></ol></li><li class="tocline"><a class="tocxref" href="#vocabulary"><bdi class="secno">3. </bdi>Vocabulary and definitions</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#classes"><bdi class="secno">3.1 </bdi>Classes</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#rml-gathermap"><bdi class="secno">3.1.1 </bdi><code>rml:GatherMap</code></a></li></ol></li><li class="tocline"><a class="tocxref" href="#properties"><bdi class="secno">3.2 </bdi>Properties</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#rml-gather"><bdi class="secno">3.2.1 </bdi><code>rml:gather</code></a></li><li class="tocline"><a class="tocxref" href="#rml-strategy"><bdi class="secno">3.2.2 </bdi><code>rml:strategy</code></a></li><li class="tocline"><a class="tocxref" href="#rml-gatheras"><bdi class="secno">3.2.3 </bdi><code>rml:gatherAs</code></a></li><li class="tocline"><a class="tocxref" href="#rml-allowemptylistandcontainer"><bdi class="secno">3.2.4 </bdi><code>rml:allowEmptyListAndContainer</code></a></li></ol></li><li class="tocline"><a class="tocxref" href="#constants"><bdi class="secno">3.3 </bdi>Constants</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#rml-append"><bdi class="secno">3.3.1 </bdi><code>rml:Append</code></a></li><li class="tocline"><a class="tocxref" href="#rml-cartesianproduct"><bdi class="secno">3.3.2 </bdi><code>rml:CartesianProduct</code></a></li></ol></li></ol></li><li class="tocline"><a class="tocxref" href="#considerations"><bdi class="secno">4. </bdi>Considerations</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#identifying-collections-and-containers-0"><bdi class="secno">4.1 </bdi>Identifying collections and containers</a></li><li class="tocline"><a class="tocxref" href="#iterations-and-gather-maps-yielding-the-same-identifier"><bdi class="secno">4.2 </bdi>Iterations and gather maps yielding the same identifier</a></li><li class="tocline"><a class="tocxref" href="#the-use-of-rr-column"><bdi class="secno">4.3 </bdi>The use of <code>rr:column</code></a></li><li class="tocline"><a class="tocxref" href="#using-a-rml-gathermap-in-various-types-of-term-map"><bdi class="secno">4.4 </bdi>Using a <code>rml:GatherMap</code> in various types of term map</a></li><li class="tocline"><a class="tocxref" href="#valid-rdf-and-well-formedness-of-collections-and-containers"><bdi class="secno">4.5 </bdi>Valid RDF and well-formedness of Collections and Containers</a></li></ol></li><li class="tocline"><a class="tocxref" href="#examples"><bdi class="secno">5. </bdi>Examples</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#dealing-with-empty-collections-and-containers"><bdi class="secno">5.1 </bdi>Dealing with empty collections and containers</a></li><li class="tocline"><a class="tocxref" href="#relationalexample"><bdi class="secno">5.2 </bdi>Relational data example</a></li><li class="tocline"><a class="tocxref" href="#using-referencing-object-map"><bdi class="secno">5.3 </bdi>Using referencing object map</a></li><li class="tocline"><a class="tocxref" href="#gatherinsubject"><bdi class="secno">5.4 </bdi>Using a gather map in a subject map</a></li></ol></li><li class="tocline"><a class="tocxref" href="#references"><bdi class="secno">A. </bdi>References</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#normative-references"><bdi class="secno">A.1 </bdi>Normative references</a></li><li class="tocline"><a class="tocxref" href="#informative-references"><bdi class="secno">A.2 </bdi>Informative references</a></li></ol></li></ol></nav>

<section id="conformance"><div class="header-wrapper"><h2 id="x1-conformance"><bdi class="secno">1. </bdi>Conformance</h2><a class="self-link" href="#conformance" aria-label="Permalink for Section 1."></a></div><p>As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.</p><p>
        The key words <em class="rfc2119">MUST</em> and <em class="rfc2119">SHOULD</em> in this document
        are to be interpreted as described in
        <a href="https://datatracker.ietf.org/doc/html/bcp14">BCP 14</a>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc2119" title="Key words for use in RFCs to Indicate Requirement Levels">RFC2119</a></cite>] [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc8174" title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">RFC8174</a></cite>]
        when, and only when, they appear in all capitals, as shown here.
      </p>
  <p data-format="markdown">
    The key words <em class="rfc2119">MUST</em> and <em class="rfc2119">SHOULD</em> in this document are to be interpreted as 
    described in [BCP 14](https://www.rfc-editor.org/info/bcp14) [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc2119" title="Key words for use in RFCs to Indicate Requirement Levels">RFC2119</a></cite>] [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc8174" title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">RFC8174</a></cite>] when, 
    and only when, they appear in all capitals, as shown here.
  </p>
</section>

<section id="overview-and-example"><div class="header-wrapper"><h2 id="overview"><bdi class="secno">2. </bdi>Overview and Example</h2><a class="self-link" href="#overview" aria-label="Permalink for Section 2."></a></div><p>This section gives a brief overview of the RML mapping language. 
It also provides simple examples of the generation of RDF collections and containers from documents and relational data.</p>
<p>Herebelow we present the three main constructs for generating collections and containers. Other predicates, and their use in examples, will be explained further down this document.</p>
<p>An <a href="#rml-gathermap"><code>rml:GatherMap</code></a> is a term map that generates a collection (<code>rdf:List</code>) or container (<code>rdf:Bag</code>, <code>rdf:Seq</code>, <code>rdf:Alt</code>). 
A gather map has a list of term maps that inform the RML processor which RDF terms have to be generated as members of the list or container. 
The <a href="#rml-gather"><code>rml:gather</code></a> predicate is used to link an instance of <a href="#rml-gathermap"><code>rml:GatherMap</code></a> with a list of term maps. The generation of a collection or container depends on the <code>rml:gatherAs</code> predicate, which may take on any of the following values: <code>rdf:List</code>, <code>rdf:Bag</code>, <code>rdf:Seq</code>,  and <code>rdf:Alt</code>.</p>
<figure id="fig-graphical-overview-of-rml-s-vocabulary-to-generate-rdf-collections-and-containers">
  <img src="../resources/images/overview.svg" alt="Graphical overview of RML's vocabulary to generate RDF collections and containers." height="886" width="995">
  <figcaption>Figure <bdi class="figno">1</bdi> <span class="fig-title">Graphical overview of RML's vocabulary to generate RDF collections and containers.</span></figcaption>
</figure>

<section id="running-example"><div class="header-wrapper"><h3 id="runningexample"><bdi class="secno">2.1 </bdi>Running example</h3><a class="self-link" href="#runningexample" aria-label="Permalink for Section 2.1"></a></div><p>In this section, the data source consists of a JSON file, <code>data.json</code>, containing the following JSON array:</p>
<pre><code class="json hljs" aria-busy="false">[ 
  { <span class="hljs-attr">"id"</span>: <span class="hljs-string">"a"</span>,  <span class="hljs-attr">"values"</span>: [ <span class="hljs-string">"1"</span> , <span class="hljs-string">"2"</span> , <span class="hljs-string">"3"</span> ] },
  { <span class="hljs-attr">"id"</span>: <span class="hljs-string">"b"</span>,  <span class="hljs-attr">"values"</span>: [ <span class="hljs-string">"4"</span> , <span class="hljs-string">"5"</span> , <span class="hljs-string">"6"</span> ] },
  { <span class="hljs-attr">"id"</span>: <span class="hljs-string">"c"</span>,  <span class="hljs-attr">"values"</span>: [ <span class="hljs-string">"7"</span> , <span class="hljs-string">"8"</span> , <span class="hljs-string">"9"</span> ] } 
]
</code></pre>
<p>The associated RML mapping starts as follows:</p>
<pre><code class="turtle hljs" aria-busy="false">@prefix rml: &lt;http://semweb.mmlab.be/ns/rml#&gt;.
@prefix rr:  &lt;http://www.w3.org/ns/r2rml#&gt;.
@prefix ql:  &lt;http://semweb.mmlab.be/ns/ql#&gt;.
@prefix ex:  &lt;http://example.com/ns&gt;.
@base        &lt;http://example.com/ns&gt;.

&lt;#TM&gt; a rr:TriplesMap;
  rml:logicalSource [
    rml:source "data.json" ;
    rml:referenceFormulation ql:JSONPath ;
    rml:iterator "$.*" ;
  ];

  rr:subjectMap [
    rr:template "{id}" ;
  ] ;
.
</code></pre>
</section><section id="a-simple-example"><div class="header-wrapper"><h3 id="simpleexample"><bdi class="secno">2.2 </bdi>A simple example</h3><a class="self-link" href="#simpleexample" aria-label="Permalink for Section 2.2"></a></div><p>Given the JSON document and the RML mapping completed with the following predicate object map:</p>
<pre><code class="turtle hljs" aria-busy="false">  rr:predicateObjectMap [
    rr:predicate ex:with ;
    rr:objectMap [
        rml:gather ( [ rml:reference "values.*" ; ] ) ;
        rml:gatherAs rdf:List ;
    ] ;
  ] ;
</code></pre>
<p>The iterator entails one iteration for each document whithin the array.
Each iteration yields an instance of collection/container whose head node is a blank node.</p>
<p>We expect the following output:</p>
<pre><code class="turtle hljs" aria-busy="false">  &lt;a&gt; ex:with ("1" "2" "3") .
  &lt;b&gt; ex:with ("4" "5" "6") .
  &lt;c&gt; ex:with ("7" "8" "9") .
</code></pre>
</section><section id="identifying-collections-and-containers"><div class="header-wrapper"><h3 id="x2-3-identifying-collections-and-containers"><bdi class="secno">2.3 </bdi>Identifying collections and containers</h3><a class="self-link" href="#identifying-collections-and-containers" aria-label="Permalink for Section 2.3"></a></div>
<p>If we now provide a template in the object map for identifying a collection/container, then each iteration yields an instance of collection/container whose head node is identified as instructed:</p>
<pre><code class="turtle hljs" aria-busy="false">  rr:predicateObjectMap [
    rr:predicate ex:with ;
    rr:objectMap [
        rr:template "list/{id}" ;
        rml:gather ( [ rml:reference "values.*" ; ] ) ;
        rml:gatherAs rdf:List ;
    ] ;
  ] ;
</code></pre>
<p>We expect the following output:</p>
<pre><code class="turtle hljs" aria-busy="false">  &lt;a&gt; ex:with &lt;list/a&gt; .
  &lt;list/a&gt; rdf:first "1" ; rdf:rest ("2" "3") .
  &lt;b&gt; ex:with &lt;list/b&gt; .
  &lt;list/b&gt; rdf:first "4" ; rdf:rest ("5" "6") .
  &lt;c&gt; ex:with &lt;list/c&gt; .
  &lt;list/c&gt; rdf:first "7" ; rdf:rest ("8" "9") .
</code></pre>
</section></section>
<section id="vocabulary-and-definitions"><div class="header-wrapper"><h2 id="vocabulary"><bdi class="secno">3. </bdi>Vocabulary and definitions</h2><a class="self-link" href="#vocabulary" aria-label="Permalink for Section 3."></a></div><p>This section introduces the classes, properties, and constants of the RML Containers and Collections specification.</p>
<section id="classes"><div class="header-wrapper"><h3 id="x3-1-classes"><bdi class="secno">3.1 </bdi>Classes</h3><a class="self-link" href="#classes" aria-label="Permalink for Section 3.1"></a></div>
<section id="rml-gathermap"><div class="header-wrapper"><h4 id="x3-1-1-rml-gathermap"><bdi class="secno">3.1.1 </bdi><code>rml:GatherMap</code></h4><a class="self-link" href="#rml-gathermap" aria-label="Permalink for Section 3.1.1"></a></div>
<p>Gather maps are term maps that use <a href="#rml-gather"><code>rml:gather</code></a> and <a href="#rml-gatheras"><code>rml:gatherAs</code></a> to generate collections and containers from a list of term maps. </p>
<p>If a gather map has no template or term type directive, at each iteration it is assumed to be generating a blank node that is the head of the collection or container.</p>
<ul>
<li>A <code>rml:GatherMap</code> <em class="rfc2119">MUST</em> have exactly one <a href="#rml-gather"><code>rml:gather</code></a> property.</li>
<li>A <code>rml:GatherMap</code> <em class="rfc2119">MUST</em> have exactly one <a href="#rml-gatheras"><code>rml:gatherAs</code></a> property.</li>
</ul>
</section></section><section id="properties"><div class="header-wrapper"><h3 id="x3-2-properties"><bdi class="secno">3.2 </bdi>Properties</h3><a class="self-link" href="#properties" aria-label="Permalink for Section 3.2"></a></div>
<section id="rml-gather"><div class="header-wrapper"><h4 id="x3-2-1-rml-gather"><bdi class="secno">3.2.1 </bdi><code>rml:gather</code></h4><a class="self-link" href="#rml-gather" aria-label="Permalink for Section 3.2.1"></a></div>
<p>The <code>rml:gather</code> informs the RML processor where the terms of a collection or container come from. This property relates a gather map with a non-empty list of term maps. 
That list of term maps may contain other gather maps, which means that this will generate nested containers and collections. One is not limited to nesting only containers or collections, both containers and collections can be mixed.</p>
<ul>
<li>The domain of <code>rml:gather</code> is <a href="#rml-gathermap"><code>rml:GatherMap</code></a>.</li>
<li>The range of <code>rml:gather</code> is a non-empty list of <code>rr:TermMap</code> instances. This list may include instances of <a href="#rml-gathermap"><code>rml:GatherMap</code></a>. We thus support the nesting of collections and containers.</li>
</ul>
</section><section id="rml-strategy"><div class="header-wrapper"><h4 id="x3-2-2-rml-strategy"><bdi class="secno">3.2.2 </bdi><code>rml:strategy</code></h4><a class="self-link" href="#rml-strategy" aria-label="Permalink for Section 3.2.2"></a></div>
<p>Declaring an <code>rml:strategy</code> on a gather map informs the processor how to create collections and containers when faced with multi-valued term maps. 
This specification defines both <code>rml:Append</code> and <code>rml:CartesianProduct</code> as instances of <code>rml:Strategy</code>. </p>
<p>In the <code>rml:Append</code> strategy, terms generated by each term map of the list are simply appended to the collection (respectively container) being constructed. Thus, only one collection (respectively container) is generated.</p>
<p>Conversely, in the <code>rml:CartesianProduct</code> strategy, the gather map generates collections (respectively containers) each containing one term generated by each term map of the list. In other words, it carries out a cartesian product between the terms generated by each term map, thus constructing as many collections (respectively containers) as the product of the number of terms from each term map. For example, if a collection contains two term maps generating respectively 2 and 3 terms, the gather map will generate 6 collections of 2 terms each.</p>
<p>A gather map does not need to specify a strategy, the default strategy is <code>rml:Append</code>.</p>
</section><section id="rml-gatheras"><div class="header-wrapper"><h4 id="x3-2-3-rml-gatheras"><bdi class="secno">3.2.3 </bdi><code>rml:gatherAs</code></h4><a class="self-link" href="#rml-gatheras" aria-label="Permalink for Section 3.2.3"></a></div>
<p>The property <code>rml:gatherAs</code> relates a gather map with the desired result type: a type of container or collections.</p>
<ul>
<li>The domain of <code>rml:gatherAs</code> is <a href="#rml-gathermap"><code>rml:GatherMap</code></a>.</li>
<li>The range of <code>rml:gatherAs</code> is one of the following: <code>rdf:Seq</code>, <code>rdf:Bag</code>, <code>rdf:Alt</code>, <code>rdf:List</code>.</li>
</ul>
</section><section id="rml-allowemptylistandcontainer"><div class="header-wrapper"><h4 id="x3-2-4-rml-allowemptylistandcontainer"><bdi class="secno">3.2.4 </bdi><code>rml:allowEmptyListAndContainer</code></h4><a class="self-link" href="#rml-allowemptylistandcontainer" aria-label="Permalink for Section 3.2.4"></a></div>
<p>The range of <code>rml:allowEmptyListAndContainer</code> is a <code>xsd:boolean</code> and is by default false. This predicate is to be used alongside <a href="#rml-gather"><code>rml:gather</code></a> and <a href="#rml-gatheras"><code>rml:gatherAs</code></a>. When true and an <a href="#rml-gather"><code>rml:gather</code></a> does not yield any element, then the gather map will generate <code>rdf:nil</code> for an RDF collection, or a resource with no members for an RDF container.</p>
<ul>
<li>The domain of <code>rml:allowEmptyListAndContainer</code> is <a href="#rml-gathermap"><code>rml:GatherMap</code></a>.</li>
<li>The range of <code>rml:allowEmptyListAndContainer</code> is <code>xsd:boolean</code>.</li>
</ul>
</section></section><section id="constants"><div class="header-wrapper"><h3 id="x3-3-constants"><bdi class="secno">3.3 </bdi>Constants</h3><a class="self-link" href="#constants" aria-label="Permalink for Section 3.3"></a></div>
<section id="rml-append"><div class="header-wrapper"><h4 id="x3-3-1-rml-append"><bdi class="secno">3.3.1 </bdi><code>rml:Append</code></h4><a class="self-link" href="#rml-append" aria-label="Permalink for Section 3.3.1"></a></div>
</section><section id="rml-cartesianproduct"><div class="header-wrapper"><h4 id="x3-3-2-rml-cartesianproduct"><bdi class="secno">3.3.2 </bdi><code>rml:CartesianProduct</code></h4><a class="self-link" href="#rml-cartesianproduct" aria-label="Permalink for Section 3.3.2"></a></div>
</section></section></section>
<section id="considerations-0"><div class="header-wrapper"><h2 id="considerations"><bdi class="secno">4. </bdi>Considerations</h2><a class="self-link" href="#considerations" aria-label="Permalink for Section 4."></a></div><section id="identifying-collections-and-containers-0"><div class="header-wrapper"><h3 id="x4-1-identifying-collections-and-containers"><bdi class="secno">4.1 </bdi>Identifying collections and containers</h3><a class="self-link" href="#identifying-collections-and-containers-0" aria-label="Permalink for Section 4.1"></a></div>
<p>An <code>rr:template</code> or <code>rml:reference</code> may be provided for the generation of blank node IDs (<code>rr:BlankNode</code>) or IRIs (<code>rr:IRI</code>). In some cases, there are challenges when identifiers are generated. The challenge generating identifiers for collections and containers: one needs to be careful when a gather map uses multi-valued references in the template or generates multiple collections and containers:</p>
<ul>
<li>In the former, the gather map must return โdeepโ copies of collections. This is to avoid only generating a new IRI or blank node identifier for the first cons-pair and hence having multiple lists sharing the same sublist.</li>
<li>In the latter, we may end up with multiple lists and containers sharing the same blank node identifier or IRI, which may produce valid RDF, but nonsensical containers and collections.</li>
</ul>
<p>If no <code>rr:template</code> or <code>rml:reference</code> is provided for generating blank node IDs (<code>rr:BlankNode</code>) or IRIs (<code>rr:IRI</code>), then each iteration generates a new blank node identifier for the collection or container.</p>
</section><section id="iterations-and-gather-maps-yielding-the-same-identifier"><div class="header-wrapper"><h3 id="x4-2-iterations-and-gather-maps-yielding-the-same-identifier"><bdi class="secno">4.2 </bdi>Iterations and gather maps yielding the same identifier</h3><a class="self-link" href="#iterations-and-gather-maps-yielding-the-same-identifier" aria-label="Permalink for Section 4.2"></a></div>
<p>If term maps were to generate the same identifier for collections and containers, the result might result in valid RDF but ill-formed RDF collections and containers. We identify two cases:</p>
<ul>
<li><p>A gather map yields the same identifier for two iterations. In that case, the nature of the resource (collection or container) remains the same, and values are appended.</p>
</li>
<li><p>Two gather maps yield the same identifier for two iterations. In that case, the nature of the resources generated by these gather maps may be different, resulting in resources of two different types (e.g., rdf:List and rdf:Bag). An RML processor will produce those as this is valid RDF, though the respective lists and containers are not well-formed.</p>
</li>
</ul>
</section><section id="the-use-of-rr-column"><div class="header-wrapper"><h3 id="x4-3-the-use-of-rr-column"><bdi class="secno">4.3 </bdi>The use of <code>rr:column</code></h3><a class="self-link" href="#the-use-of-rr-column" aria-label="Permalink for Section 4.3"></a></div>
<p>In RML, <code>rr:column</code> is considered a subproperty of <code>rml:reference</code>. One can still avail of <code>rr:column</code> when creating mappings for relational databases. The use of <code>rr:column</code> is not discouraged, but one is encouraged to favor <code>rml:reference</code>. </p>
</section><section id="using-a-rml-gathermap-in-various-types-of-term-map"><div class="header-wrapper"><h3 id="x4-4-using-a-rml-gathermap-in-various-types-of-term-map"><bdi class="secno">4.4 </bdi>Using a <code>rml:GatherMap</code> in various types of term map</h3><a class="self-link" href="#using-a-rml-gathermap-in-various-types-of-term-map" aria-label="Permalink for Section 4.4"></a></div>
<p>Although most examples demonstrate the use of a gather map in the context of an object map, a gather map is a regular term map.
As such, it can be used in other types of term maps such as a subject or predicate map.</p>
<p>Term maps generate single RDF terms to be used as the terms of RDF triples.
If such a term map generates a collection or container by means of a gather map, the term retained to form an RDF triple is the head node of the collection or container.
In the case of an RDF list, this is the node that is the subject of the first <code>rdf:first</code> predicate.</p>
<p>The <a href="#gatherinsubject">examples section</a> demonstrates how a gather map can be used within a subject map.</p>
</section><section id="valid-rdf-and-well-formedness-of-collections-and-containers"><div class="header-wrapper"><h3 id="x4-5-valid-rdf-and-well-formedness-of-collections-and-containers"><bdi class="secno">4.5 </bdi>Valid RDF and well-formedness of Collections and Containers</h3><a class="self-link" href="#valid-rdf-and-well-formedness-of-collections-and-containers" aria-label="Permalink for Section 4.5"></a></div>
<p>The mapping language proposed here guarantees the generation of valid RDF. However, the well-formedness of RDF collections and containers is up to the person creating and managing the mappings. An RML processor with support for gather maps may include a validator for collections and containers, but this is not required. In this section, we provide an example of a mapping that generates valid RDF but ill-formed lists.</p>
<p>Given the JSON document below.</p>
<pre><code class="json hljs" aria-busy="false">[ 
  { <span class="hljs-attr">"id"</span>: <span class="hljs-string">"a"</span>,  <span class="hljs-attr">"values"</span>: [ <span class="hljs-string">"1"</span> , <span class="hljs-string">"2"</span> ] },
  { <span class="hljs-attr">"id"</span>: <span class="hljs-string">"a"</span>,  <span class="hljs-attr">"values"</span>: [ <span class="hljs-string">"3"</span> , <span class="hljs-string">"4"</span> ] },
  { <span class="hljs-attr">"id"</span>: <span class="hljs-string">"b"</span>,  <span class="hljs-attr">"values"</span>: [ <span class="hljs-string">"5"</span> , <span class="hljs-string">"6"</span> ] } 
]
</code></pre>
<p>We are going to create an RML mapping that will generate valid RDF, but ill-formed lists. In the mapping below, we will generate blank nodes who are identified by the value of <code>id</code> in each element of our JSON document.</p>
<pre><code class="turtle hljs" aria-busy="false">@prefix rml: &lt;http://semweb.mmlab.be/ns/rml#&gt;.
@prefix rr:  &lt;http://www.w3.org/ns/r2rml#&gt;.
@prefix ql:  &lt;http://semweb.mmlab.be/ns/ql#&gt;.
@prefix ex:  &lt;http://example.com/ns&gt;.
@base        &lt;http://example.com/ns&gt;.

&lt;#TM&gt; a rr:TriplesMap;
  rml:logicalSource [
    rml:source "data.json" ;
    rml:referenceFormulation ql:JSONPath ;
    rml:iterator "$.*" ;
  ] ;

  rr:subjectMap [
    rr:template "{id}" ;
  ] ;

  rr:predicateObjectMap [
    rr:predicate ex:with ;
    rr:objectMap [
        # Generate blank node identifiers for lists based on the value of "id"
        rr:template "{id}" ;
        rml:gather ( [ rml:reference "values.*" ; ] ) ;
        rml:gatherAs rdf:List ;
    ] ;
  ] ;
.
</code></pre>
<p>The first two iterations will refer to the same blank node, as they both have the value <code>"a"</code> for the key <code>id</code>. As two lists are being generated, this blank node will have two <code>rdf:first</code> and two <code>rdf:rest</code> properties as that blank node is used for two cons-pairs. This cons-pair is ill-formed and hence so are the lists. The third iteration does yield a well-formed list. The output generated with this mapping is, however, valid RDF.</p>
<pre><code class="turtle hljs" aria-busy="false">@prefix ex:  &lt;http://example.org/ns#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .

ex:a    ex:with     _:b0 .

_:b0    rdf:first   1 , 3 ;
        rdf:rest    ( 2 ) ;
        rdf:rest    ( 4 ) .

ex:b    ex:with (5 6) .
</code></pre>
</section></section>
<section id="examples-0"><div class="header-wrapper"><h2 id="examples"><bdi class="secno">5. </bdi>Examples</h2><a class="self-link" href="#examples" aria-label="Permalink for Section 5."></a></div><p>In this section, we present additional examples and describe the expected output.</p>
<section id="dealing-with-empty-collections-and-containers"><div class="header-wrapper"><h3 id="x5-1-dealing-with-empty-collections-and-containers"><bdi class="secno">5.1 </bdi>Dealing with empty collections and containers</h3><a class="self-link" href="#dealing-with-empty-collections-and-containers" aria-label="Permalink for Section 5.1"></a></div>
<p>By default, <a href="#rml-allowemptylistandcontainer"><code>rml:allowEmptyListAndContainer</code></a> is false. 
Thus, processing the following JSON document with the predicate object map provided in the <a href="#runningexample">running example</a> would not yield any result for the document with <code>"id": "d"</code>.</p>
<pre><code class="json hljs" aria-busy="false">[ 
  { <span class="hljs-attr">"id"</span>: <span class="hljs-string">"a"</span>,  <span class="hljs-attr">"values"</span>: [ <span class="hljs-string">"1"</span> , <span class="hljs-string">"2"</span> , <span class="hljs-string">"3"</span> ] },
  { <span class="hljs-attr">"id"</span>: <span class="hljs-string">"b"</span>,  <span class="hljs-attr">"values"</span>: [ <span class="hljs-string">"4"</span> , <span class="hljs-string">"5"</span> , <span class="hljs-string">"6"</span> ] },
  { <span class="hljs-attr">"id"</span>: <span class="hljs-string">"c"</span>,  <span class="hljs-attr">"values"</span>: [ <span class="hljs-string">"7"</span> , <span class="hljs-string">"8"</span> , <span class="hljs-string">"9"</span> ] },
  { <span class="hljs-attr">"id"</span>: <span class="hljs-string">"d"</span>,  <span class="hljs-attr">"values"</span>: [] } 
]
</code></pre>
<p>However, when we override the value for this property and set it to true:</p>
<pre><code class="turtle hljs" aria-busy="false">  rr:predicateObjectMap [
    rr:predicate ex:with ;
    rr:objectMap [
        rml:allowEmptyListAndContainer true ;
        rml:gather ( [ rml:reference "values.*" ; ] ) ;
        rml:gatherAs rdf:List ;
    ] ;
  ] ;
</code></pre>
<p>then the predicate object map will generate:</p>
<pre><code class="turtle hljs" aria-busy="false">  &lt;a&gt; ex:with ("1" "2" "3") .
  &lt;b&gt; ex:with ("4" "5" "6") .
  &lt;c&gt; ex:with ("7" "8" "9") .
  &lt;d&gt; ex:with () .
</code></pre>
<p>There is one special case when dealing with empty <em>collections</em>. Since <code>rdf:nil</code> is reserved for the empty list, an RML processor <em class="rfc2119">MUST</em> replace each IRI or blank node that is an empty list with <code>rdf:nil</code>. 
In other words, when the following predicate object map is used:</p>
<pre><code class="turtle hljs" aria-busy="false">  rr:predicateObjectMap [
    rr:predicate ex:with ;
    rr:objectMap [
        rr:template "list/{id}" ;
        rml:allowEmptyListAndContainer true ;
        rml:gather ( [ rml:reference "values.*" ; ] ) ;
        rml:gatherAs rdf:List ;
    ] ;
  ] ;
</code></pre>
<p>then the docmment with <code>"id": "d"</code> entails an empty list, that is a list whose head node is <code>rdf:nil</code> and therefore has no IRI.
We expect the following output where</p>
<pre><code class="turtle hljs" aria-busy="false">  &lt;a&gt; ex:with &lt;list/a&gt; .
  &lt;list/a&gt; rdf:first "1" ; rdf:rest ("2" "3") .
  &lt;b&gt; ex:with &lt;list/b&gt; .
  &lt;list/b&gt; rdf:first "4" ; rdf:rest ("5" "6") .
  &lt;c&gt; ex:with &lt;list/c&gt; .
  &lt;list/c&gt; rdf:first "7" ; rdf:rest ("8" "9") .
  &lt;d&gt; ex:with () . 
</code></pre>
</section><section id="relational-data-example"><div class="header-wrapper"><h3 id="relationalexample"><bdi class="secno">5.2 </bdi>Relational data example</h3><a class="self-link" href="#relationalexample" aria-label="Permalink for Section 5.2"></a></div><p>In this section, we use the following relational database and document for our example.</p>
<p>Table <code>BOOK</code>:</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>TITLE</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Frankenstein</td>
</tr>
<tr>
<td>2</td>
<td>The Long Earth</td>
</tr>
</tbody></table>
<p>Table <code>AUTHOR</code>:</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>TITLE</th>
<th>FNAME</th>
<th>LNAME</th>
<th>BOOKID</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td>Mary</td>
<td>Shelley</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>Sir</td>
<td>Terry</td>
<td>Pratchett</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>Stephen</td>
<td>Baxter</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>The following mapping will relate instances of authors to names. The names of authors are, for the sake of the example, represented as bags containing a title, first name, and lastname.</p>
<pre><code class="turtle hljs" aria-busy="false">&lt;#AuthorTM&gt;
    rr:logicalTable [ rr:tableName "AUTHOR" ; ] ;
    rr:subjectMap [ rr:template "/person/{ID}" ; ] ;
    rr:predicateObjectMap [
        rr:predicate ex:name ;
        rr:objectMap [
            rml:reference "ID" ; rr:termType rr:BlankNode ;
            rml:gather ( 
                [ rml:reference "TITLE" ]  [ rml:reference "FNAME" ]  [ rml:reference "LNAME" ] 
            ) ;
            rml:gatherAs rdf:Bag ;
        ] ;
    ] ;
.
</code></pre>
<p>In this example we generate, for each row in table <code>AUTHOR</code>, an blank node of type <code>rdf:Bag</code>. Each such bag "gathers" values from different term maps. The execution of this mapping will produce the following result:</p>
<pre><code class="turtle hljs" aria-busy="false">&lt;person/1&gt; ex:name [ a rdf:Bag; rdf:_1 "Mary"; rdf:_2 "Shelley" ] . 
&lt;person/2&gt; ex:name [ a rdf:Bag; rdf:_1 "Sir"; rdf:_2 "Terry"; rdf:_3 "Pratchett" ] . 
&lt;person/3&gt; ex:name [ a rdf:Bag; rdf:_1 "Stephen"; rdf:_2 "Baxter" ] .
</code></pre>
<p>While not shown in this example, different term maps allow to collect terms of different types: resources, literals, typed or language-tagged literals, etc. The fourth record in the table did not generate a bag, since each term map in the gather map did not yield a value. 
By default, empty lists and containers are withheld. One does have the possibility to keep those with <a href="#rml-allowemptylistandcontainer"><code>rml:allowEmptyListAndContainer</code></a>`.</p>
</section><section id="using-referencing-object-map"><div class="header-wrapper"><h3 id="x5-3-using-referencing-object-map"><bdi class="secno">5.3 </bdi>Using referencing object map</h3><a class="self-link" href="#using-referencing-object-map" aria-label="Permalink for Section 5.3"></a></div>
<p>Continuing with the <a href="#relationalexample">relational data example</a>, here we relate books to authors with a <code>rr:parentTriplesMap</code>. The authors of a book are represented as a list.</p>
<pre><code class="turtle hljs" aria-busy="false">&lt;#BookTM&gt;
    rr:logicalTable [ rr:tableName "BOOK" ; ] ;
    rr:subjectMap [ rr:template "/book/{ID}" ; ] ;
    rr:predicateObjectMap [
        rr:predicate ex:writtenBy ;
        rr:objectMap [
            rml:reference "ID" ; rr:termType rr:BlankNode ;
            rml:gather ( 
                [ 
                    rr:parentTriplesMap &lt;#AuthorTM&gt;;
                    rr:joinCondition [ rr:child "ID" ; rr:parent "BOOKID" ; ] ;
                ] 
            ) ;
            rml:gatherAs rdf:List;
        ] ;
    ] ;
.
</code></pre>
<p>Intuitively, we will join each record (or iteration) with data from the parent triples map. The join may yield one or more results, which are then gathered into a list. The execution of this mapping will produce the following RDF:</p>
<pre><code class="turtle hljs" aria-busy="false">&lt;book/1&gt; ex:writtenby ( &lt;person/1&gt; ) . 
&lt;book/2&gt; ex:writtenby ( &lt;person/2&gt; &lt;person/3&gt; ) .
</code></pre>
<p>In RML, it is assumed that each term map is multi-valued. That this, each term map may return one or more values. The default behavior is to append the values in the order of the term maps appearing in the gather map.</p>
</section><section id="using-a-gather-map-in-a-subject-map"><div class="header-wrapper"><h3 id="gatherinsubject"><bdi class="secno">5.4 </bdi>Using a gather map in a subject map</h3><a class="self-link" href="#gatherinsubject" aria-label="Permalink for Section 5.4"></a></div><p>Here we exemplify the use of a term map in a subject map. Continuing with the JSON file from the <a href="#runningexample">running example</a>, the following mapping generates an RDF sequence whose head node is used to state provenance information on that sequence:</p>
<pre><code class="turtle hljs" aria-busy="false">@prefix rml: &lt;http://semweb.mmlab.be/ns/rml#&gt;.
@prefix rr:  &lt;http://www.w3.org/ns/r2rml#&gt;.
@prefix ql:  &lt;http://semweb.mmlab.be/ns/ql#&gt;.
@prefix ex:  &lt;http://example.com/ns&gt;.
@base        &lt;http://example.com/ns&gt;.

&lt;#TM&gt; a rr:TriplesMap;
  rml:logicalSource [
    rml:source "data.json" ;
    rml:referenceFormulation ql:JSONPath ;
    rml:iterator "$.*" ;
  ];

  rr:subjectMap [
    rr:template "seq/{id}" ;
    rml:gather ( [ rml:reference "values.*" ; ] ) ;
    rml:gatherAs rdf:Seq ;  
  ] ;
  
  rr:predicateObjectMap [
    rr:predicate prov:wasDerivedFrom ;
    rr:object &lt;data.json&gt; ;
  ] .
</code></pre>
<p>The expected result is:</p>
<pre><code class="turtle hljs" aria-busy="false">  &lt;seq/a&gt; rdf:_1 "1" ; rdf:_2 "2" ; rdf:_3 "3" .
  &lt;seq/a&gt; prov:wasDerivedFrom &lt;data.json&gt; .
  
  &lt;seq/b&gt; rdf:_1 "4" ; rdf:_2 "5" ; rdf:_3 "6" .
  &lt;seq/b&gt; prov:wasDerivedFrom &lt;data.json&gt; .
  
  &lt;seq/c&gt; rdf:_1 "7" ; rdf:_2 "8" ; rdf:_3 "9" .
  &lt;seq/c&gt; prov:wasDerivedFrom &lt;data.json&gt; .
</code></pre>
</section></section>



<section id="references" class="appendix"><div class="header-wrapper"><h2 id="a-references"><bdi class="secno">A. </bdi>References</h2><a class="self-link" href="#references" aria-label="Permalink for Appendix A."></a></div><section id="normative-references"><div class="header-wrapper"><h3 id="a-1-normative-references"><bdi class="secno">A.1 </bdi>Normative references</h3><a class="self-link" href="#normative-references" aria-label="Permalink for Appendix A.1"></a></div>
    
    <dl class="bibliography"><dt id="bib-rfc2119">[RFC2119]</dt><dd>
      <a href="https://www.rfc-editor.org/rfc/rfc2119"><cite>Key words for use in RFCs to Indicate Requirement Levels</cite></a>. S. Bradner.  IETF. March 1997. Best Current Practice. URL: <a href="https://www.rfc-editor.org/rfc/rfc2119">https://www.rfc-editor.org/rfc/rfc2119</a>
    </dd><dt id="bib-rfc8174">[RFC8174]</dt><dd>
      <a href="https://www.rfc-editor.org/rfc/rfc8174"><cite>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</cite></a>. B. Leiba.  IETF. May 2017. Best Current Practice. URL: <a href="https://www.rfc-editor.org/rfc/rfc8174">https://www.rfc-editor.org/rfc/rfc8174</a>
    </dd></dl>
  </section><section id="informative-references"><div class="header-wrapper"><h3 id="a-2-informative-references"><bdi class="secno">A.2 </bdi>Informative references</h3><a class="self-link" href="#informative-references" aria-label="Permalink for Appendix A.2"></a></div>
    
    <dl class="bibliography"><dt id="bib-rdf11-concepts">[RDF11-Concepts]</dt><dd>
      <a href="https://www.w3.org/TR/rdf11-concepts/"><cite>RDF 1.1 Concepts and Abstract Syntax</cite></a>.  W3C. 25 February 2014. W3C Recommendation. URL: <a href="https://www.w3.org/TR/rdf11-concepts/">https://www.w3.org/TR/rdf11-concepts/</a>
    </dd><dt id="bib-rml">[RML]</dt><dd>
      <a href="https://rml.io/specs/rml"><cite>RDF Mapping Language (RML)</cite></a>.  RML team. 06 October 2020. Unofficial Draft. URL: <a href="https://rml.io/specs/rml">https://rml.io/specs/rml</a>
    </dd></dl>
  </section></section><p role="navigation" id="back-to-top">
    <a href="#title"><abbr title="Back to Top">โ</abbr></a>
  </p><script id="respec-dfn-panel">(() => {
// @ts-check
if (document.respec) {
  document.respec.ready.then(setupPanel);
} else {
  setupPanel();
}

function setupPanel() {
  const listener = panelListener();
  document.body.addEventListener("keydown", listener);
  document.body.addEventListener("click", listener);
}

function panelListener() {
  /** @type {HTMLElement} */
  let panel = null;
  return event => {
    const { target, type } = event;

    if (!(target instanceof HTMLElement)) return;

    // For keys, we only care about Enter key to activate the panel
    // otherwise it's activated via a click.
    if (type === "keydown" && event.key !== "Enter") return;

    const action = deriveAction(event);

    switch (action) {
      case "show": {
        hidePanel(panel);
        /** @type {HTMLElement} */
        const dfn = target.closest("dfn, .index-term");
        panel = document.getElementById(`dfn-panel-for-${dfn.id}`);
        const coords = deriveCoordinates(event);
        displayPanel(dfn, panel, coords);
        break;
      }
      case "dock": {
        panel.style.left = null;
        panel.style.top = null;
        panel.classList.add("docked");
        break;
      }
      case "hide": {
        hidePanel(panel);
        panel = null;
        break;
      }
    }
  };
}

/**
 * @param {MouseEvent|KeyboardEvent} event
 */
function deriveCoordinates(event) {
  const target = /** @type HTMLElement */ (event.target);

  // We prevent synthetic AT clicks from putting
  // the dialog in a weird place. The AT events sometimes
  // lack coordinates, so they have clientX/Y = 0
  const rect = target.getBoundingClientRect();
  if (
    event instanceof MouseEvent &&
    event.clientX >= rect.left &&
    event.clientY >= rect.top
  ) {
    // The event probably happened inside the bounding rect...
    return { x: event.clientX, y: event.clientY };
  }

  // Offset to the middle of the element
  const x = rect.x + rect.width / 2;
  // Placed at the bottom of the element
  const y = rect.y + rect.height;
  return { x, y };
}

/**
 * @param {Event} event
 */
function deriveAction(event) {
  const target = /** @type {HTMLElement} */ (event.target);
  const hitALink = !!target.closest("a");
  if (target.closest("dfn:not([data-cite]), .index-term")) {
    return hitALink ? "none" : "show";
  }
  if (target.closest(".dfn-panel")) {
    if (hitALink) {
      return target.classList.contains("self-link") ? "hide" : "dock";
    }
    const panel = target.closest(".dfn-panel");
    return panel.classList.contains("docked") ? "hide" : "none";
  }
  if (document.querySelector(".dfn-panel:not([hidden])")) {
    return "hide";
  }
  return "none";
}

/**
 * @param {HTMLElement} dfn
 * @param {HTMLElement} panel
 * @param {{ x: number, y: number }} clickPosition
 */
function displayPanel(dfn, panel, { x, y }) {
  panel.hidden = false;
  // distance (px) between edge of panel and the pointing triangle (caret)
  const MARGIN = 20;

  const dfnRects = dfn.getClientRects();
  // Find the `top` offset when the `dfn` can be spread across multiple lines
  let closestTop = 0;
  let minDiff = Infinity;
  for (const rect of dfnRects) {
    const { top, bottom } = rect;
    const diffFromClickY = Math.abs((top + bottom) / 2 - y);
    if (diffFromClickY < minDiff) {
      minDiff = diffFromClickY;
      closestTop = top;
    }
  }

  const top = window.scrollY + closestTop + dfnRects[0].height;
  const left = x - MARGIN;
  panel.style.left = `${left}px`;
  panel.style.top = `${top}px`;

  // Find if the panel is flowing out of the window
  const panelRect = panel.getBoundingClientRect();
  const SCREEN_WIDTH = Math.min(window.innerWidth, window.screen.width);
  if (panelRect.right > SCREEN_WIDTH) {
    const newLeft = Math.max(MARGIN, x + MARGIN - panelRect.width);
    const newCaretOffset = left - newLeft;
    panel.style.left = `${newLeft}px`;
    /** @type {HTMLElement} */
    const caret = panel.querySelector(".caret");
    caret.style.left = `${newCaretOffset}px`;
  }

  // As it's a dialog, we trap focus.
  // TODO: when <dialog> becomes a implemented, we should really
  // use that.
  trapFocus(panel, dfn);
}

/**
 * @param {HTMLElement} panel
 * @param {HTMLElement} dfn
 * @returns
 */
function trapFocus(panel, dfn) {
  /** @type NodeListOf<HTMLAnchorElement> elements */
  const anchors = panel.querySelectorAll("a[href]");
  // No need to trap focus
  if (!anchors.length) return;

  // Move focus to first anchor element
  const first = anchors.item(0);
  first.focus();

  const trapListener = createTrapListener(anchors, panel, dfn);
  panel.addEventListener("keydown", trapListener);

  // Hiding the panel releases the trap
  const mo = new MutationObserver(records => {
    const [record] = records;
    const target = /** @type HTMLElement */ (record.target);
    if (target.hidden) {
      panel.removeEventListener("keydown", trapListener);
      mo.disconnect();
    }
  });
  mo.observe(panel, { attributes: true, attributeFilter: ["hidden"] });
}

/**
 *
 * @param {NodeListOf<HTMLAnchorElement>} anchors
 * @param {HTMLElement} panel
 * @param {HTMLElement} dfn
 * @returns
 */
function createTrapListener(anchors, panel, dfn) {
  const lastIndex = anchors.length - 1;
  let currentIndex = 0;
  return event => {
    switch (event.key) {
      // Hitting "Tab" traps us in a nice loop around elements.
      case "Tab": {
        event.preventDefault();
        currentIndex += event.shiftKey ? -1 : +1;
        if (currentIndex < 0) {
          currentIndex = lastIndex;
        } else if (currentIndex > lastIndex) {
          currentIndex = 0;
        }
        anchors.item(currentIndex).focus();
        break;
      }

      // Hitting "Enter" on an anchor releases the trap.
      case "Enter":
        hidePanel(panel);
        break;

      // Hitting "Escape" returns focus to dfn.
      case "Escape":
        hidePanel(panel);
        dfn.focus();
        return;
    }
  };
}

/** @param {HTMLElement} panel */
function hidePanel(panel) {
  if (!panel) return;
  panel.hidden = true;
  panel.classList.remove("docked");
}
})()</script><script src="https://www.w3.org/scripts/TR/2021/fixup.js"></script></body><grammarly-desktop-integration data-grammarly-shadow-root="true"></grammarly-desktop-integration></html>